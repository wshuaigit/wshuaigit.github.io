<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础提高(一)]]></title>
    <url>%2Fpost%2F4cc0092f.html</url>
    <content type="text"><![CDATA[Java基础提高（一）最近开始Java的复习，弥补一下从前的知识盲区且深入底层去学习Java，通过了解源码更加深入的去了解Java。 1.面向过程和面向对象的区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道C语言是一门完全面向过程的语言，当我们要是实现某些需求时，我们更在意的是如何通过一个函数去实现该需求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而在Java中我们更加在意的是对象，哪些对象拥有哪些功能。当我们面对一个需求时，让这些对象去实现某些需求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以将大象装入冰箱为例，面向过程我们可能会这样做：我们把冰箱门打开，我们把大象装进冰箱，我们把冰箱关闭。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而面向对象我们可能会这样做：首先进行分析，该需求有两个对象，冰箱和大象。冰箱有如下功能：打开、关闭。大象有如下功能：走到冰箱中。实现该需求过程如下：冰箱开门，大象走进冰箱，冰箱关门。 显而易见：面向过程更加在意的是我们实现这个需求的过程，而面向对象则是通过对对象的分析，让其他对象去完成该需求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你刚接触Java，可能并不能体会到什么叫面向对象，比如我们写一个方法，你觉得这个实现过程和面向过程的实现并没有区别。这是因为面向对象只是在宏观上是面向对象，微观上依然是面向过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，面向过程是我们自己去做，面向对象是让别人去做。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然面向面向并不仅仅局限于此，其三大特征为：封装、继承、多态。 2.JDK和JRE的区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDK是Java程序的开发包，而Jre只是Java程序的运行环境。JDK包含了Jre，JDK中的bin目录中有如下程序javac.exejava.exe,javap.exe等,javac用于编译Java程序的源代码，生成字节码文件；java用于运行编译后的字节码文件，javap用于反编译，可以查看编译后的指令等。 3.基本数据类型和包装类型 基本数据类型 包装类型 字节 boolean Boolean - byte Byte 1 short Short 2 char Character 2 int Integer 4 float Float 4 double Double 8 long Long 8 void Void - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、boolean类型所占的存储空间的大小没有明确知道，仅定义为能够取字面值true或false。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、一个boolean变量在编译后以一个int代替，一个boolean数组编译后，数组中每个成员是一个byte。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、《Java编程思想》中将void列为基本类型，但是其他资料并没有认为void是基本类型，Void的源码中说明该类是一个占位符类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、在Java中，认为一切皆对象，但是由于基本类型并不是对象，便引入了包装类型，实现基本类型和包装类型的相互转化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、基本类型和包装类型的区别：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(一)初值不同，如boolean的初值为false,int的初值为0，而包装类型的初值为null(注意：这里的初值是位于类中的成员变量而不是方法中的变量，方法中的变量必须赋初值才能使用)；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(二)存储位置不同，基本类型存储位置在栈中，而包装类型的存储位置位于堆中；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(三)在与集合类共同使用时，必须使用包装类型。 4.自动装箱和拆箱&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDK1.5后引入了自动装箱和拆箱，从而实现基本类型和包装类型的自动转换。自动装箱调用的是valueOf()方法，而自动拆箱调用的是(基本类型+Value())方法，例如Integer实现自动拆箱调用的是intValue()。 1234567Integer a = 1; Integer b = 1; System.out.println(a == b); Integer c = new Integer(1); Integer d = new Integer(1); System.out.println(c == d); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行段代码后，输出应该为： 12truefalse &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是因为 == 比较的是地址，而Integer存在缓存池，进行自动装箱且值位于-128 - 127时，从缓存池中返回对应的Integer的引用，所以a,b的引用相同。而c、d并没有进行自动装箱，而是自己在堆中 new 对象，每个对象的引用。 12345678public static Integer valueOf(int i) &#123; // IntegerCache.low = -128; // IntegerCache.high; high的值默认为127 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) IntegerCache.cache[] 是一个Integer数组，包含了 low到high 的引用 return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么对于其他的包装类型，是否也同样有缓存池呢？ 1234567Boolean a = true;Boolean b = true;System.out.println(a == b);Boolean c = new Boolean(true);Boolean d = new Boolean(true);System.out.println(c == d); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出结果如下： 12truefalse &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过观察源码，发现类中有这样两个常量：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们进行自动装箱时，返回这两个对象的引用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再来看看其他的包装类： 123Double a = 1.0;Double b = 1.0;System.out.println(a == b); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;猜测一下答案吧，可能会有点出乎你的意料，答案是： 1true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这当然是因为并不存在缓存池了，想想也是。对于浮点型，要创建它的缓存池好像也做不到吧。 包装类型 是否存在缓存池 范围 Boolean 不存在，但是存在两个常量 Byte 存在 -127 - 128 Short 存在 -127 - 128 Charcater 存在 0 - 127 Integer 存在 -127 - 128 Float 不存在 Double 不存在 Long 存在 -127 - 128 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是Integer缓存池的上限可以我们自己定义，但是不能超过127，而其他包装类型的范围都是已经确定了的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不知道你有没有写过这样的代码？将一个int直接自动装箱为Double。如果没有的话，可以去尝试一下，结果可能会出乎你的意料。 1234567public static void main(String[] args) &#123; Double a = 1; Double b = new Double(1);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上所示，你可能会认为Double自动装箱的话调vlaueOf(double d)那么的话，我的1可以自动类型转换为1.0，那我当然可以实现自动装箱了，然而编译结果如下： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以这样理解，自动装箱的过程中关闭了自动类型转换。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--简单工厂模式]]></title>
    <url>%2Fpost%2F4cc0092f.html</url>
    <content type="text"><![CDATA[简单工厂模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相信很多人都听过设计模式吧，但是也只是局限于听说。很多人认为设计模式并没啥用啊（当然也包括我），我自己写的代码也可以完成需求，为啥还要设计模式呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在你学习之后会感叹代码还可以这么写，同时也能够更加熟练的运用面向对象的思想。本系列的文章来源于《大话设计模式》，感兴趣的朋友们可以找来阅读一番，很不错的一本书。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接开始正文吧，我们要实现两个数的运算，用户输入两个数字和一个操作符后，返回运算结果。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相信各位能够很容易实现该代码如下： 1234567891011121314151617181920212223public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入数字A:&quot;); String strNumA = scanner.nextLine(); System.out.print(&quot;请输入数字B:&quot;); String strNumB = scanner.nextLine(); System.out.println(&quot;请输入运算符:&quot;); String strOper = scanner.nextLine(); if(&quot;+&quot;.equals(strOper))&#123; System.out.println(Double.parseDouble(strNumA) + Double.parseDouble(strNumB)); &#125; if(&quot;-&quot;.equals(strOper))&#123; System.out.println(Double.parseDouble(strNumA) - Double.parseDouble(strNumB)); &#125; if(&quot;*&quot;.equals(strOper))&#123; System.out.println(Double.parseDouble(strNumA) * Double.parseDouble(strNumB)); &#125; if(&quot;/&quot;.equals(strOper))&#123; System.out.println(Double.parseDouble(strNumA) / Double.parseDouble(strNumB)); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我们可以发现，该段代码依然有很多问题，如：用户输入非法值时，我们没有进行异常处理；其次，当进行除法运算时，除数为0的话，我们也并没有进行判断；接着不断我输入哪个运算符，四个if语句都执行了，虽然说计算机运算速度，但是我们写出精炼的代码，能够让别人感觉到你的代码水平较高。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;改进后的代码如下： 1234567891011121314151617181920212223242526272829303132333435public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入数字A:&quot;); String strNumA = scanner.nextLine(); System.out.print(&quot;请输入数字B:&quot;); String strNumB = scanner.nextLine(); System.out.print(&quot;请输入运算符:&quot;); String strOper = scanner.nextLine(); try &#123; double result = 0; if (&quot;+&quot;.equals(strOper)) &#123; result = Double.parseDouble(strNumA) + Double.parseDouble(strNumB); &#125; else if (&quot;-&quot;.equals(strOper)) &#123; result = Double.parseDouble(strNumA) - Double.parseDouble(strNumB); &#125; else if (&quot;*&quot;.equals(strOper)) &#123; result = Double.parseDouble(strNumA) * Double.parseDouble(strNumB); &#125; else if (&quot;/&quot;.equals(strOper)) &#123; if(Double.parseDouble(strNumB)!=0) result = Double.parseDouble(strNumA) / Double.parseDouble(strNumB); else System.out.println(&quot;除数不能为0!&quot;); &#125;else&#123; System.out.println(&quot;请输入指定运算符!&quot;); return; &#125; System.out.println(&quot;运算结果:&quot;+result); &#125;catch (NumberFormatException e)&#123; System.out.println(&quot;请输入合法值!&quot;); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;观察上面的代码后，是不是觉得你写的代码已经很完善了，但是这是一个完全面向过程的程序吧。面向对象的三大特征封装、继承、多态好像并没有使用吧。该段程序的耦合度很高，高质量的程序应该是耦合度很低的，所以我们应该将业务逻辑与业务逻辑无关的分离，降低彼此之间的耦合度。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Operation &#123; public static double getResult(double numA,double numB,String oper) throws Exception &#123; double result = 0; switch (oper)&#123; case &quot;+&quot;: result = numA + numB; break; case &quot;-&quot;: result = numA - numB; break; case &quot;*&quot;: result = numA * numB; break; case &quot;/&quot;: if(numB != 0) &#123; result = numA / numB; &#125;else&#123; throw new Exception(&quot;除数不能为0!&quot;); &#125; break; default: throw new Exception(&quot;请输入指定运算符!&quot;); &#125; return result; &#125;&#125;public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入数字A:&quot;); String strNumA = scanner.nextLine(); System.out.print(&quot;请输入数字B:&quot;); String strNumB = scanner.nextLine(); System.out.print(&quot;请输入运算符:&quot;); String strOper = scanner.nextLine(); try &#123; double result = Operation.getResult(Double.parseDouble(strNumA),Double.parseDouble(strNumB),strOper); System.out.println(&quot;运算结果：&quot;+result); &#125;catch (NumberFormatException e)&#123; System.out.println(&quot;请输入合法值!&quot;); &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如此一来，我们便将调用者与业务逻辑之间进行了解耦和。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，如果我们要增加其他运算呢？如求平方根，求次方的话会怎么做？相信大家的想法是在Operation类中增加case语句不就好了吗？但是这样做的话，我们得更改原程序的代码。通常来说，是很忌讳直接去修改原程序的代码。这时，我们就可以运用面向对象的其他特征了。12345678910111213141516171819202122232425262728293031323334353637383940public abstract class Operation &#123; public abstract double getResult(double numA,double numB) throws Exception;&#125;class OperAdd extends Operation&#123; @Override public double getResult(double numA, double numB) &#123; return numA + numB; &#125;&#125;class OperSub extends Operation&#123; @Override public double getResult(double numA, double numB) &#123; return numA - numB; &#125;&#125;class OperMul extends Operation&#123; @Override public double getResult(double numA, double numB) &#123; return numA * numB; &#125;&#125;class OperDiv extends Operation&#123; @Override public double getResult(double numA, double numB) throws Exception &#123; if(numB == 0) throw new Exception(&quot;除数不能为0!&quot;); return numA / numB; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通过判断运算符的类型，继承父类生成合适的子类对象，利用多态即可。这样的话，当需要其他功能时，我们只需要继续去继承父类即可。而我们生成合适子类的过程中便用到了简单工厂模式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单工厂模式示例代码如下： 12345678910111213141516171819202122public class OperFactory &#123; public Operation createOper(String oper) throws Exception &#123; Operation operation = null; switch (oper)&#123; case &quot;+&quot;: operation = new OperAdd(); break; case &quot;-&quot;: operation = new OperSub(); break; case &quot;*&quot;: operation = new OperMul(); break; case &quot;/&quot;: operation = new OperDiv(); break; default: throw new Exception(&quot;请输入指定运算符&quot;); &#125; return operation; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们进行运算时，让工厂产生合适的子类对象，这样我们就可以进行运算了。123456789101112131415161718192021222324252627public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入数字A:&quot;); String strNumA = scanner.nextLine(); System.out.print(&quot;请输入数字B:&quot;); String strNumB = scanner.nextLine(); System.out.print(&quot;请输入运算符:&quot;); String strOper = scanner.nextLine(); try &#123; //生成工厂对象 OperFactory factory = new OperFactory(); //生成合适的子类对象 Operation oper = factory.createOper(strOper); //利用多态进行计算 double result = oper.getResult(Double.parseDouble(strNumA),Double.parseDouble(strNumB)); System.out.println(&quot;运算结果:&quot;+result); &#125;catch (NumberFormatException e)&#123; System.out.println(&quot;请输入合法数字！&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个OperFactory像不像一个工厂呢？如饮料厂生产饮料，根据用户的需求去生产合适的饮料。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能还挺过静态工厂模式，那么什么时静态工厂呢？很简单，不过是将生产子类的方法由对象方法提升至类方法，这样我们就可以不用生成工厂对象，直接通过类去调用该方法即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习了简单工厂模式后，我们总结一下什么时候时候该设计模式，首先对需求进行分习，如上可以分离出一个抽象类：运算类。然后该类的方法在不同的条件下有不同的执行过程。那么，此时我们便可以使用简单工厂模式。]]></content>
      <categories>
        <category>实际模式</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
</search>
