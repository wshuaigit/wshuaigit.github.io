<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础提高(三)]]></title>
    <url>%2Fpost%2F9d02b266.html</url>
    <content type="text"><![CDATA[Java基础提高(三) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次开始介绍String类及其相关类，String首先声明这是一个引用类型。很多学习了一段时间Java的人依然认为这是一个基本类型，大概是因为像基本类型一样经常使用吧。但必须知道这并不是基本类型，而是引用类型，否则人家问你时不是闹了个笑话吗？ 1.String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么要介绍String，因为在我们的程序代码中，会经常用到String，而String存在一些知识盲区你可能并不了解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先要知道的是该类是一个final类，即你并不能去继承该类。为什么要这样设计？我个人有两点看法：（1）因为sun认为该类已经很完美了，不需要被继承；2）我们在传输数据时，大量的用到字符串，如果你继承String，却不能够严谨完善的实现其功能，容易造成数据不安全。 1public final class String &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其次，我们都知道String是一个不可变字符串，那么为什么是不可变字符串？是因为String数组内部封装了一个final数组？ 1private final char value[]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于被final修饰的引用类型，只是其地址值不可以改变，那么其数组下标中的元素可以改变吗？答案是可以的，如下所示： 12345678910111213141516171819202122232425public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; String s = "abcd"; //获得Class对象 Class c = s.getClass(); //让s1和s的地址相同，判断反射改变String的值后地址有没有发生变化 String s1 = s; //输出true System.out.println(s1 == s); //获得String的成员变量，即final数组 Field value = c.getDeclaredField("value"); //因为数组为private，所以需要取消语法检查 value.setAccessible(true); char[] array = (char[])value.get(s); //输出[a, b, c, d] System.out.println(Arrays.toString(array)); //输出abcd System.out.println(s); array[3] = 'a'; //[a, b, c, a] System.out.println(Arrays.toString(array)); //输出abca System.out.println(s); //输出true System.out.println(s1 == s); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意最后输出的是true，那么则说明地址并没有发生变化，我们确实改变了String的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么事情这么简单吗？如果我们打印hashCode会有变化吗？运行后发现hashCode的值并没有发生变化，这是为什么呢？要知道不在反射的情况下，这两个的字符串的hashCode并不相同？这是因为在我们创建String对象的时候，便已经计算了hashCode的值？如下： 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而我们在反射的过程中，并没有进行hashCode值的更新，所以如果要反射更换值时要更新hashCode，同时只能改变数组元素的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在如下一组代码： 12345String s1 = "abc"; String s2 = "abc"; String s3 = new String("abc"); System.out.println(s1 == s2); System.out.println(s1 == s3); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出： 12truetrue &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是因为以非 new 的方式创建String时，首先到字符串常量池中查找目标字符串。若不存在，则在常量池中直接创建该字符串并返回引用。若存在，则直接返回返回引用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而执行到String s3 = new String(“abc”);时，我们每一次new时，都是在堆中创建对象，又因为字符串常量池已经存在目标值，所以内存图如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们使用new创建字符串时，如果目标串不在字符串常量池时，会将目标串加到字符串常量池中，然后继续在堆中分配内存。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里留下一个问题，即如果我们以下面这种方式创建字符串的话，那么会不会将字符串加入到常量池中？ 1String s = new String("a")+new String("b"); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先可以明确的知道”a”和”b”在字符串常量池中，那么”ab”在不在字符串常量池中呢？我们待会进行验证。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String类中存在这样一个方法intern() 123456789101112131415161718192021222324/** * Returns a canonical representation for the string object. * &lt;p&gt; * A pool of strings, initially empty, is maintained privately by the * class &#123;@code String&#125;. * &lt;p&gt; * When the intern method is invoked, if the pool already contains a * string equal to this &#123;@code String&#125; object as determined by * the &#123;@link #equals(Object)&#125; method, then the string from the pool is * returned. Otherwise, this &#123;@code String&#125; object is added to the * pool and a reference to this &#123;@code String&#125; object is returned. * &lt;p&gt; * It follows that for any two strings &#123;@code s&#125; and &#123;@code t&#125;, * &#123;@code s.intern() == t.intern()&#125; is &#123;@code true&#125; * if and only if &#123;@code s.equals(t)&#125; is &#123;@code true&#125;. * &lt;p&gt; * All literal strings and string-valued constant expressions are * interned. String literals are defined in section 3.10.5 of the * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;. * * @return a string that has the same contents as this string, but is * guaranteed to be from a pool of unique strings. */ public native String intern(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从注释可知，当我们调用这个方法时，如果常量池中存在和目标串相同的值，则返回常量池中的地址。否则，直接返回引用，并且将目标串加入到字符串常量池中。示例如下： 1234String s1 = new String("ab"); String s2 = s1.intern(); System.out.println(s1 == s2); // 输出：false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存图如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以这里输出的是false。现在回到我们上面的问题，当我们以 + 进行字符串拼接时会不会加入到字符串常量池中？示例代码如下： 1234String s1 = new String("a") + new String("b"); String s2 = s1.intern(); System.out.println(s1 == s2); // 输出：true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即我们在执行String s1 = new String(“a”) + new String(“b”);并不会将”ab”加入到字符串常量池中。 2.StringBuilder &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;正是由于String是不可变字符串，我们对String的每一次修改操作都产生了新的String。这样有时不符合我们的需求，所以便又产生了可变字符串。StringBuilder和StringBuffer。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要声明的便是StringBuild是可变字符串，接着我们开始研究其源码。通过观察源码后，发现StringBuild通过继承AbstractStringBuilder获得其成员变量，而AbstractStringBuilder存在一个char数组。 12345678910abstract class AbstractStringBuilder implements Appendable, CharSequence &#123; /** * The value is used for character storage. */ char[] value; /** * The count is the number of characters used. */ int count; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们创建StringBuild数组时，默认创建一个长度为16的字符数组。 123public StringBuilder() &#123; super(16); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们给StringBuild添加元素时，有人认为是将整体放入数组中的下标，通过观察源码这是并不是正确。如下： 123StringBuilder sb = new StringBuilder(); sb.append(123); System.out.println(sb.length()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并不是将123整个放入数组中的元素，而是分割开,分别放入数组中的元素。 3.StringBuffer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你观察StringBuffer的源码，发现StringBuilder的差别几乎没有，唯一的大区别大概就是StringBuffer中的方法被synchronized，而synchronized的作用就是为了保证线程安全。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是线程安全问题？即多个线程同时对一份资源进行读写操作（注意：只进行读操作并不会产生线程安全问题），这样会导致数据混乱。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而在多线程环境下，我们可以通过synchronized实现每次对一份资源进行读写操作只有一个线程执行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以StringBuffer与StringBuild最大的区别就是线程是否安全。 类 是否线程安全 是否可变 String 安全 不可变 StringBuilder 不安全 可变 StringBuffer 安全 可变 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;个人博客：https://wshuaigit.github.io/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础提高(二)]]></title>
    <url>%2Fpost%2Fe3f1924d.html</url>
    <content type="text"><![CDATA[Java基础提高(二)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继续上次的内容，现在开始介绍Java中经常被使用的类，你不得不了解的类。 1. Object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道，Java是一门面向对象的语言，而面向对象的三大特征是：封装、继承、多态。在继承中，如果我们没有直接声明一个类的父类，那么这个类的父类便是Object。所以Object类可以算是所有类的祖宗类，这便是我们不得不关注该类的原因。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们开始进行该类方法的介绍： 权限 方法名 作用 private registerNatives() 让JVM找到本地方法 public getClass() 获得Class对象 public hashCode() 获得哈希值 public equals(Object obj) 比较两个对象是否相等 protected clone() 克隆对象 public toString() 打印该对象的信息 public notify() 唤醒一个等待中的线程 public notifyAll() 唤醒多个等待中的线程 public wait() 让当前线程等待，并释放锁 public wait(long timeout) 让当前线程等待，直到指定时间或被唤醒 public wait(long timeout, int nanos) 同wait(long timeout)，time = 1000000*timeout+nanos protected finalize() 被垃圾回收器清除之前执行 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、在该类中，我们可以看到有一些方法被native修饰，那么为什么这些方法要被native修饰呢？我们都知道任意一种语言都希望效率越高越好，如C语言，经历了这么多年依然很流行，正是由于其与底层最接近。而面向对象的语言很难像C语言一样高效，为了在其他语言中使用C语言，便产生了native method.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、每一个类都有一个其对应的Class对象，该对象被保存在一个同名的.class文件中。通过该Class对象，我们可以创建对象。通过该对象，我们可以获得该类的任意信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、在数组中，我们如果要寻找一个元素，如果不知道该元素的下标，那么便只能所数组头部进行搜索，这样造成的后果便是查找元素慢。倘若我们一开始就知道该元素的下标，那么我们只要找数组指定下标元素，这样效率是不是很高？而哈希值的原理便是基于此，存在这样一张哈希表，我们通过哈希值可以快速找到目标元素。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈希值的常用算法：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)直接定址法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)数字分析法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3)平方取中法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4)折叠法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5)除留余数法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(6)随机数法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是不是存在这样的疑惑？为什么需要这么多种计算方法？一种不就够了吗？这是因为对于不同类，肯定都是不相同的，那么所有的类都使用一种方法的话肯定是很不合适的。我们应该就可能避免哈希值相同的情况。 123456789@Test public void test()&#123; String s1 = &quot;通话&quot;; String s2 = &quot;重地&quot;; System.out.println(s1.hashCode()); //输出：1179395 System.out.println(s2.hashCode()); //输出：1179395 &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上面可以看出，不同的对象可能会产生相同的哈希值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、有时候我们需要判断两个对象是否相等，那么这个时候就需要重写equal(Object o)方法。如下存在这样一个类： 12345678910111213public class Student &#123; private int age; private String name; public Student()&#123; super(); &#125; public Student(int age,String name)&#123; this.age = age; this.name = name; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要判断这两个对象是否值相等，可以这样做： 123456public static void main(String[] args) &#123; Student s1 = new Student(20,&quot;张三&quot;); Student s2 = new Student(20,&quot;张三&quot;); System.out.println(s1.equals(s2)); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案是false，为什么两个对象值相等，比较或却是false呢？因为我们没有重写equals(Object o)方法，调用的是父类Object的方法,代码如下： 123public boolean equals(Object obj) &#123; return (this == obj); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于两个对象都是在堆中new出的，所以他们有不同的地址，而==对于引用类型来说比较的是地址，所以答案是false。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么我们不想比较地址，就只能重写equals方法了，如下： 123456789101112131415161718@Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; &#125; @Override public int hashCode() &#123; int result = age; result = 31 * result + (name != null ? name.hashCode() : 0); return result; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常来说，我们会同时重写equlas方法和hashCode方法。哈希值相等但不一定是同一个对象，同一个对象一定哈希值相等。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、克隆对象，以上面的类为例，我们要使用clone()方法需实现 Cloneable 接口。 123456public static void main(String[] args) throws CloneNotSupportedException &#123; Student s1 = new Student(20,&quot;张三&quot;); Student s2 = (Student)s1.clone(); System.out.println(s1 == s2 ); System.out.println(s1.equals(s2)); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出如下：false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出，clone方法只是将值复制过去，地址并不相同。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6、打印对象的信息，如果我们直接输出对象，调用toString()方法。如下： 12Student s1 = new Student(20,&quot;张三&quot;); System.out.println(s1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出：Student@bd555&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们不重写toString()的话，默认调用父类的toString()。代码如下： 123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认为：类名 + @ + 十六进制哈希值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：很多人认为hashCode的值就是地址值，这一说法并不完全正确，因为在我们进行hashCode方法重写时，哈希算法由我们自己写，我们怎么可能决定内存地址呢？但是对于Object类来说，确实时将地址转为int值。 1234(This is typically implemented by converting the internaladdress of the object into an integer, but this implementationtechnique is not required by theJava&amp;trade; programming language.) 7、在C语言中，如果我们想要释放内存的话，必须手动进行释放。但是Java简化了这一过程，由垃圾回收器替我们完成。而重写finalize()后，当垃圾回收器清理没有被引用的对象时，会执行该方法。 1234@Override protected void finalize() throws Throwable &#123; System.out.println(&quot;执行finalize()方法&quot;); &#125; 1234567public static void main(String[] args) throws CloneNotSupportedException &#123; new Student(20,&quot;张三&quot;); new Student(20,&quot;张三&quot;); new Student(20,&quot;张三&quot;); System.gc();&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用该方法后，可能会有如下输出： 123执行finalize()方法执行finalize()方法执行finalize()方法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果并没有进行输出的话，也很正常，尝试多运行几次。因为System.gc()的作用只是提醒虚拟机应该进行清理垃圾了，但虚拟机并不一定会听取。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与线程相关的方法在后期详细介绍。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--简单工厂模式]]></title>
    <url>%2Fpost%2F4cc0092f.html</url>
    <content type="text"><![CDATA[简单工厂模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相信很多人都听过设计模式吧，但是也只是局限于听说。很多人认为设计模式并没啥用啊（当然也包括我），我自己写的代码也可以完成需求，为啥还要设计模式呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在你学习之后会感叹代码还可以这么写，同时也能够更加熟练的运用面向对象的思想。本系列的文章来源于《大话设计模式》，感兴趣的朋友们可以找来阅读一番，很不错的一本书。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接开始正文吧，我们要实现两个数的运算，用户输入两个数字和一个操作符后，返回运算结果。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相信各位能够很容易实现该代码如下： 1234567891011121314151617181920212223public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入数字A:&quot;); String strNumA = scanner.nextLine(); System.out.print(&quot;请输入数字B:&quot;); String strNumB = scanner.nextLine(); System.out.println(&quot;请输入运算符:&quot;); String strOper = scanner.nextLine(); if(&quot;+&quot;.equals(strOper))&#123; System.out.println(Double.parseDouble(strNumA) + Double.parseDouble(strNumB)); &#125; if(&quot;-&quot;.equals(strOper))&#123; System.out.println(Double.parseDouble(strNumA) - Double.parseDouble(strNumB)); &#125; if(&quot;*&quot;.equals(strOper))&#123; System.out.println(Double.parseDouble(strNumA) * Double.parseDouble(strNumB)); &#125; if(&quot;/&quot;.equals(strOper))&#123; System.out.println(Double.parseDouble(strNumA) / Double.parseDouble(strNumB)); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我们可以发现，该段代码依然有很多问题，如：用户输入非法值时，我们没有进行异常处理；其次，当进行除法运算时，除数为0的话，我们也并没有进行判断；接着不断我输入哪个运算符，四个if语句都执行了，虽然说计算机运算速度，但是我们写出精炼的代码，能够让别人感觉到你的代码水平较高。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;改进后的代码如下： 1234567891011121314151617181920212223242526272829303132333435public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入数字A:&quot;); String strNumA = scanner.nextLine(); System.out.print(&quot;请输入数字B:&quot;); String strNumB = scanner.nextLine(); System.out.print(&quot;请输入运算符:&quot;); String strOper = scanner.nextLine(); try &#123; double result = 0; if (&quot;+&quot;.equals(strOper)) &#123; result = Double.parseDouble(strNumA) + Double.parseDouble(strNumB); &#125; else if (&quot;-&quot;.equals(strOper)) &#123; result = Double.parseDouble(strNumA) - Double.parseDouble(strNumB); &#125; else if (&quot;*&quot;.equals(strOper)) &#123; result = Double.parseDouble(strNumA) * Double.parseDouble(strNumB); &#125; else if (&quot;/&quot;.equals(strOper)) &#123; if(Double.parseDouble(strNumB)!=0) result = Double.parseDouble(strNumA) / Double.parseDouble(strNumB); else System.out.println(&quot;除数不能为0!&quot;); &#125;else&#123; System.out.println(&quot;请输入指定运算符!&quot;); return; &#125; System.out.println(&quot;运算结果:&quot;+result); &#125;catch (NumberFormatException e)&#123; System.out.println(&quot;请输入合法值!&quot;); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;观察上面的代码后，是不是觉得你写的代码已经很完善了，但是这是一个完全面向过程的程序吧。面向对象的三大特征封装、继承、多态好像并没有使用吧。该段程序的耦合度很高，高质量的程序应该是耦合度很低的，所以我们应该将业务逻辑与业务逻辑无关的分离，降低彼此之间的耦合度。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Operation &#123; public static double getResult(double numA,double numB,String oper) throws Exception &#123; double result = 0; switch (oper)&#123; case &quot;+&quot;: result = numA + numB; break; case &quot;-&quot;: result = numA - numB; break; case &quot;*&quot;: result = numA * numB; break; case &quot;/&quot;: if(numB != 0) &#123; result = numA / numB; &#125;else&#123; throw new Exception(&quot;除数不能为0!&quot;); &#125; break; default: throw new Exception(&quot;请输入指定运算符!&quot;); &#125; return result; &#125;&#125;public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入数字A:&quot;); String strNumA = scanner.nextLine(); System.out.print(&quot;请输入数字B:&quot;); String strNumB = scanner.nextLine(); System.out.print(&quot;请输入运算符:&quot;); String strOper = scanner.nextLine(); try &#123; double result = Operation.getResult(Double.parseDouble(strNumA),Double.parseDouble(strNumB),strOper); System.out.println(&quot;运算结果：&quot;+result); &#125;catch (NumberFormatException e)&#123; System.out.println(&quot;请输入合法值!&quot;); &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如此一来，我们便将调用者与业务逻辑之间进行了解耦和。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，如果我们要增加其他运算呢？如求平方根，求次方的话会怎么做？相信大家的想法是在Operation类中增加case语句不就好了吗？但是这样做的话，我们得更改原程序的代码。通常来说，是很忌讳直接去修改原程序的代码。这时，我们就可以运用面向对象的其他特征了。12345678910111213141516171819202122232425262728293031323334353637383940public abstract class Operation &#123; public abstract double getResult(double numA,double numB) throws Exception;&#125;class OperAdd extends Operation&#123; @Override public double getResult(double numA, double numB) &#123; return numA + numB; &#125;&#125;class OperSub extends Operation&#123; @Override public double getResult(double numA, double numB) &#123; return numA - numB; &#125;&#125;class OperMul extends Operation&#123; @Override public double getResult(double numA, double numB) &#123; return numA * numB; &#125;&#125;class OperDiv extends Operation&#123; @Override public double getResult(double numA, double numB) throws Exception &#123; if(numB == 0) throw new Exception(&quot;除数不能为0!&quot;); return numA / numB; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通过判断运算符的类型，继承父类生成合适的子类对象，利用多态即可。这样的话，当需要其他功能时，我们只需要继续去继承父类即可。而我们生成合适子类的过程中便用到了简单工厂模式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单工厂模式示例代码如下： 12345678910111213141516171819202122public class OperFactory &#123; public Operation createOper(String oper) throws Exception &#123; Operation operation = null; switch (oper)&#123; case &quot;+&quot;: operation = new OperAdd(); break; case &quot;-&quot;: operation = new OperSub(); break; case &quot;*&quot;: operation = new OperMul(); break; case &quot;/&quot;: operation = new OperDiv(); break; default: throw new Exception(&quot;请输入指定运算符&quot;); &#125; return operation; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们进行运算时，让工厂产生合适的子类对象，这样我们就可以进行运算了。123456789101112131415161718192021222324252627public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入数字A:&quot;); String strNumA = scanner.nextLine(); System.out.print(&quot;请输入数字B:&quot;); String strNumB = scanner.nextLine(); System.out.print(&quot;请输入运算符:&quot;); String strOper = scanner.nextLine(); try &#123; //生成工厂对象 OperFactory factory = new OperFactory(); //生成合适的子类对象 Operation oper = factory.createOper(strOper); //利用多态进行计算 double result = oper.getResult(Double.parseDouble(strNumA),Double.parseDouble(strNumB)); System.out.println(&quot;运算结果:&quot;+result); &#125;catch (NumberFormatException e)&#123; System.out.println(&quot;请输入合法数字！&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个OperFactory像不像一个工厂呢？如饮料厂生产饮料，根据用户的需求去生产合适的饮料。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能还挺过静态工厂模式，那么什么时静态工厂呢？很简单，不过是将生产子类的方法由对象方法提升至类方法，这样我们就可以不用生成工厂对象，直接通过类去调用该方法即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习了简单工厂模式后，我们总结一下什么时候时候该设计模式，首先对需求进行分习，如上可以分离出一个抽象类：运算类。然后该类的方法在不同的条件下有不同的执行过程。那么，此时我们便可以使用简单工厂模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础提高(一)]]></title>
    <url>%2Fpost%2F4cc0092f.html</url>
    <content type="text"><![CDATA[Java基础提高（一）最近开始Java的复习，弥补一下从前的知识盲区且深入底层去学习Java，通过了解源码更加深入的去了解Java。 1.面向过程和面向对象的区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道C语言是一门完全面向过程的语言，当我们要是实现某些需求时，我们更在意的是如何通过一个函数去实现该需求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而在Java中我们更加在意的是对象，哪些对象拥有哪些功能。当我们面对一个需求时，让这些对象去实现某些需求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以将大象装入冰箱为例，面向过程我们可能会这样做：我们把冰箱门打开，我们把大象装进冰箱，我们把冰箱关闭。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而面向对象我们可能会这样做：首先进行分析，该需求有两个对象，冰箱和大象。冰箱有如下功能：打开、关闭。大象有如下功能：走到冰箱中。实现该需求过程如下：冰箱开门，大象走进冰箱，冰箱关门。 显而易见：面向过程更加在意的是我们实现这个需求的过程，而面向对象则是通过对对象的分析，让其他对象去完成该需求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你刚接触Java，可能并不能体会到什么叫面向对象，比如我们写一个方法，你觉得这个实现过程和面向过程的实现并没有区别。这是因为面向对象只是在宏观上是面向对象，微观上依然是面向过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，面向过程是我们自己去做，面向对象是让别人去做。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然面向面向并不仅仅局限于此，其三大特征为：封装、继承、多态。 2.JDK和JRE的区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDK是Java程序的开发包，而Jre只是Java程序的运行环境。JDK包含了Jre，JDK中的bin目录中有如下程序javac.exejava.exe,javap.exe等,javac用于编译Java程序的源代码，生成字节码文件；java用于运行编译后的字节码文件，javap用于反编译，可以查看编译后的指令等。 3.基本数据类型和包装类型 基本数据类型 包装类型 字节 boolean Boolean - byte Byte 1 short Short 2 char Character 2 int Integer 4 float Float 4 double Double 8 long Long 8 void Void - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、boolean类型所占的存储空间的大小没有明确知道，仅定义为能够取字面值true或false。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、一个boolean变量在编译后以一个int代替，一个boolean数组编译后，数组中每个成员是一个byte。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、《Java编程思想》中将void列为基本类型，但是其他资料并没有认为void是基本类型，Void的源码中说明该类是一个占位符类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、在Java中，认为一切皆对象，但是由于基本类型并不是对象，便引入了包装类型，实现基本类型和包装类型的相互转化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、基本类型和包装类型的区别：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(一)初值不同，如boolean的初值为false,int的初值为0，而包装类型的初值为null(注意：这里的初值是位于类中的成员变量而不是方法中的变量，方法中的变量必须赋初值才能使用)；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(二)存储位置不同，基本类型存储位置在栈中，而包装类型的存储位置位于堆中；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(三)在与集合类共同使用时，必须使用包装类型。 4.自动装箱和拆箱&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDK1.5后引入了自动装箱和拆箱，从而实现基本类型和包装类型的自动转换。自动装箱调用的是valueOf()方法，而自动拆箱调用的是(基本类型+Value())方法，例如Integer实现自动拆箱调用的是intValue()。 1234567Integer a = 1; Integer b = 1; System.out.println(a == b); Integer c = new Integer(1); Integer d = new Integer(1); System.out.println(c == d); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行段代码后，输出应该为： 12truefalse &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是因为 == 比较的是地址，而Integer存在缓存池，进行自动装箱且值位于-128 - 127时，从缓存池中返回对应的Integer的引用，所以a,b的引用相同。而c、d并没有进行自动装箱，而是自己在堆中 new 对象，每个对象的引用。 12345678public static Integer valueOf(int i) &#123; // IntegerCache.low = -128; // IntegerCache.high; high的值默认为127 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) IntegerCache.cache[] 是一个Integer数组，包含了 low到high 的引用 return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么对于其他的包装类型，是否也同样有缓存池呢？ 1234567Boolean a = true;Boolean b = true;System.out.println(a == b);Boolean c = new Boolean(true);Boolean d = new Boolean(true);System.out.println(c == d); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出结果如下： 12truefalse &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过观察源码，发现类中有这样两个常量：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们进行自动装箱时，返回这两个对象的引用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再来看看其他的包装类： 123Double a = 1.0;Double b = 1.0;System.out.println(a == b); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;猜测一下答案吧，可能会有点出乎你的意料，答案是： 1true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这当然是因为并不存在缓存池了，想想也是。对于浮点型，要创建它的缓存池好像也做不到吧。 包装类型 是否存在缓存池 范围 Boolean 不存在，但是存在两个常量 Byte 存在 -127 - 128 Short 存在 -127 - 128 Charcater 存在 0 - 127 Integer 存在 -127 - 128 Float 不存在 Double 不存在 Long 存在 -127 - 128 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是Integer缓存池的上限可以我们自己定义，但是不能超过127，而其他包装类型的范围都是已经确定了的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不知道你有没有写过这样的代码？将一个int直接自动装箱为Double。如果没有的话，可以去尝试一下，结果可能会出乎你的意料。 1234567public static void main(String[] args) &#123; Double a = 1; Double b = new Double(1);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上所示，你可能会认为Double自动装箱的话调vlaueOf(double d)那么的话，我的1可以自动类型转换为1.0，那我当然可以实现自动装箱了，然而编译结果如下： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以这样理解，自动装箱的过程中关闭了自动类型转换。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
