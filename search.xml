<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[最简单的方式理解KMP]]></title>
    <url>%2Fpost%2F24ab7905.html</url>
    <content type="text"><![CDATA[KMP算法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在求解字符串的匹配问题时，最容易让人想到的便是BF算法，但是由于BF的时间复杂度为O(n*m)，所以并不是很好。而KMP算法同样用于求解字符串的匹配问题，其时间复杂度为O(n+m)，但是并不是所有人都能理解这种算法，甚至去选择死记硬背。这里并不建议如此做，直接进入正题吧。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KMP算法的时间复杂度低的关键便是主串的指针不回溯，只需要更改模式串的指针即可。然而很多人都知道KMP算法的原理，最主要的便是求模式串的next数组，给其一个模式串，可以很快的在纸上求出next数组。但是在面对next数组的代码时，却不能够看懂。终究原因，还是没有完全理解next数组。在这里希望可以用最简单的语言帮助你理解KMP算法。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们假设next[j] = k ,那么意味着当指针指向模式串的j时，其真前缀串和真后缀串的长度都为k，所以通过下面的图可以得到 a 串的长度和b串的长度都为k，并且他们的值相匹配。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么现在我们要求出next[j+1]的值，应该怎么做呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们只需要判断模式串p的p[k]和p[j]是否相等，如果相等的话，那么是不是便有p[j+1] =p[j]+1。注意这里我们可以知道p[j] = p[k]，即p[j+1] = p[k]+1,我们将在next的代码中用到。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么如果不相等呢？那么我们只能在k的前面寻找和j相等的那一个指针。假设next[k] = h,那么我们可以得到下图：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么意味着1区域和2区域（即绿色区域）的字符串相匹配且长度为h，有因为a区域和b区域的字符串相匹配，所以1区域和区域的字符串相匹配，所以我们需要判断p[h]和p[j]是否相等，如果相等，则有 next[j+1] = h + 1，即next[j+1]等于next[k]+1。如果不相等的话，我们继续递归划分h前面的字符串即可，直到到-1. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来便介绍代码吧，如下： 1234567891011121314151617public static int[] getNext(String str)&#123; int[] next = new int[str.length()]; next[0] = -1; // 因为首字母的前缀串为空串，所以这里规定为-1 int j = 0; int k = -1; while(j &lt; next.length-1)&#123; if(k==-1 || str.charAt(j) == str.charAt(k))&#123; // k == next[k] == next[j] ++k; // next[k] + 1 ++j; next[j] = k; // next[j+1] = next[k] + 1 &#125;else&#123; //不匹配进行递归操作 k = next[k]; &#125; &#125; return next;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上便是next的求法，不管p[k]和p[j]是否匹配，在我们用图推导时结论都是next[j]=next[k]+1. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在求得next数组后，我们便进行字符串的匹配，同样的假设主串的第i个位置和模式串的第j个位置发生了不匹配，那么可得到下面这张图： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以知道黄色区域的字符串相互匹配，那么现在我们的目标是在模式串的黄色区域找等于i位置的下标。在我们所求过的next数组，可以知道：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;粉色区域为j的前缀子串和后缀子串，对应主串中的如下区域：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以知道粉色区域相互匹配，那么现在我们只需要判断i和k的字符是否相匹配，如果匹配的话，j = next[j]。如果不匹配的话，我们继续递归下去即可，类似于递归求next数组。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不知道你有没有这样的疑问，为什么要在k位置判断是否相等，k+1不可以吗？答案是不可以的，如果以k+1为例，那么则认为k的字符包含在粉色区域。如果包含进去的话，next[j]又是一个新的k，有陷入了刚才的问题。 12345678910111213141516171819public static int KMP(String str,String pattern)&#123; int[] next = getNext(str); int strLen = str.length()-pattern.length(); int i = 0; int j = 0; while(i &lt;= strLen &amp;&amp; j &lt; pattern.length())&#123; if(j == -1 || str.charAt(i) == pattern.charAt(j))&#123; // j == -1,即说明模式串的首字符和主串的i都不匹配 i++; j++; &#125;else&#123; j = next[j]; &#125; if(j == pattern.length())&#123; break; &#125; &#125; return i-j; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来我们进行KMP的优化算法，优化算法同样是为了求解next数组，但为什么要求解next数组呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假设p[k] == p[j]，那么是不是意味着i位置的字符和k位置的字符不相等呢，所以此时我们直需要判断next[k]位置的字符和i是否匹配，可以跳过一些没必要判断的字符。而next[k] = next[j],即 i 是否和next[next[j]]相匹配。 12345678910111213141516171819public static int[] getNext2(String str)&#123; int[] next = new int[str.length()]; next[0] = -1; int j = 0; int k = -1; while(j &lt; next.length-1)&#123; if(k==-1 || str.charAt(j) == str.charAt(k))&#123; ++k; ++j; if(str.charAt(j) == str.charAt(k)) next[j] = next[k]; else next[j] = k; &#125;else&#123; k = next[k]; &#125; &#125; return next; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上便是KMP算法的求解了，面对一堆的关系，建议以画图的方式来表示出来，更加直观，容易理解。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java基础提高（五）--ArrayList]]></title>
    <url>%2Fpost%2Fdc79d497.html</url>
    <content type="text"><![CDATA[Java基础提高（五） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来我们学习Java中已经封装好的容器，很多人对于容器只是知道其怎么使用以及其特性，却不知道其原理，希望这里可以帮助到你。相信知道原理后，能够更加熟练的帮助我们运用相关容器。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们可以查看一下常用容器之间的继承关系。如图所示： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上图中我们可以看出，从Map及其子类以外，其他容器的基类都是来源于Collection。所以我们先来探究一下Collection接口，可以看出Collection接口继承Iterabler接口，而Iterabler接口的作用是用于迭代集合。所以Collection接口下的子类都可以使用迭代器去迭代，当我们需要实现Collection接口时，那么就必须要去实现iterator()方法。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collection接口中常用的方法： 方法 作用 int size() 查看容器中元素个数 boolean isEmpty() 判断容器是否为空 boolean contains(Object o) 容器中是否包含目标元素 Iterator iterator() 对容器中元素进行迭代 Object[] toArray() 将容器中的所有元素转为数组 T[] toArray(T[] a) 将容器中的元素转为指定类型 boolean add(E e) 添加元素 boolean remove(Object o) 删除元素 boolean containsAll(Collection&lt;?&gt; c) 容器中是否包含另一个容器 boolean addAll(Collection&lt;? extends E&gt; c) 将另一个容器中的全部元素添加到该容器中 boolean removeAll(Collection&lt;?&gt; c) 删除与目标容器中相同的元素 retainAll 仅保留此集合中包含的元素，求交集 void clear() 清空容器中的元素 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过继承关系，我们可以知道其子类同样拥有上面的方法。接下来我们学习最常用的容器，List。我们先来观察下List及其常用子类的继承关系图。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List接口中多出来的方法有： 方法 作用 E get(int index) 返回容器中指定位置元素 E set(int index, E element) 设置容器中指定位置的元素为新的元素 void add(int index, E element) 在指定位置添加新元素 E remove(int index) 删除指定位置的元素 int indexOf(Object o) 返回目标元素的位置 int lastIndexOf(Object o) 返回目标元素的位置，从后往前找 ListIterator listIterator() 返回迭代器（双向） List subList(int fromIndex, int toIndex) 截取子集 sort(Comparator&lt;? super E&gt; c) 排序 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来我们便直接看可以直接使用的类ArrayList，首先观察其用于的成员变量，如下： 1234private static final int DEFAULT_CAPACITY = 10;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;transient Object[] elementData;private int size; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面我们可以看到，ArrayList内部封装了一个数组，所以我们存储的元素都存储在一个数组中，如果是数组的话，那么便从在索引，我们变可以直接通过索引操作元素。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后我们研究其构造方法： 1234567891011121314151617181920212223242526public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125;public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125;public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上面三个重载的构造方法，我们可以得出这样的结论：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayList不指定大小时，默认大小是10.否则大小为我们指定的大小。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来我们查看一下，往容器中添加元素是如何实现的。 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ensureCapacityInternal()的作用是判断容器是否需要扩容，具体实现如下： 123456789101112131415161718private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calculateCapacity(Object[] elementData, int minCapacity)中elementData为实际存储元素的大小，minCapacity为,新的长度（从前数组中存储元素的个数+1）.如果elementData为空，则返回minCapacity和10比较后的最大值，否则返回minCapacity。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ensureExplicitCapacity(int minCapacity)中minCapacity为新的长度（从前数组中存储元素的个数+1 或者 10），modCount++的作用Java中的fail-fast 机制，直接进入if语句，如果新的长度大于数组的长度，则调用grow()方法，即进行扩容。 1234567891011private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面的代码中我们可以看出，ArrayList是以数组长度的1.5倍进行扩容。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至于扩容后，底层则是调用System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength))，将从前数组中的元素拷贝到新数组中。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来我们查看一下ArrayList其他比较有趣的方法：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、trimToSize() 12345678public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果数组中存储的元素小于数组的长度，我们又进行了一次和扩容时所调用的方法Arrays.copyOf(elementData, size);那么这样做的目的是什么呢？随着数组长度基数的增大，我们每扩容一次都是1.5倍进行扩充，这样可能会产生较大的无用空间，而该方法以当前数组中存储的元素个数为数组长度，这样便节约了空间。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、retainAll(Collection&lt;?&gt; c) 1234public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除和目标集合相同的元素。 123456789101112131415ArrayList arrayList = new ArrayList(3); arrayList.add(1); arrayList.add(2); arrayList.add(3); arrayList.add(4); System.out.println(arrayList); // [1, 2, 3, 4] ArrayList arrayList2 = new ArrayList(3); arrayList2.add(1); arrayList2.add(2); arrayList.retainAll(arrayList2); System.out.println(arrayList2); // [1, 2] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、iterator()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然我们可以通过数组索引去遍历这个容器，但是对于不是由数组实现的容器，我们经常会使用迭代器去遍历容器，这里我们探究一下迭代器的实现原理。 123public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该方法返回了一个Itr类的对象，而Itr类是ArrayList的一个内部类，内部类的特点是可以直接访问外部类的成员。 1234567891011121314151617181920212223242526272829303132333435363738394041424344private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // 要返回下一个元素的索引 int lastRet = -1; // 返回的上一个元素的索引 int expectedModCount = modCount; // 判断我们是否有对容器进行过增删操作 Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上是我们常用迭代器的方法，在hasNext()中，我们判断要返回元素的索引如果不等于容器中存储元素的个数，则代表存在下一个元素。然后我们next()中获取元素时，如果符合条件，则把 cursor 的值 赋值给 lastRet，cursor++，然后返回 lastRet 索引处的元素。相信绝大多数的人都写过这样的代码： 123456789ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("A"); list.add("B"); list.add("C"); Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext())&#123; String str = it.next(); list.remove(str); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样会引发一个异常：ConcurrentModificationException，我们探究一下为什么在迭代过程中不可以对容器进行删除或添加操作。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们执行list.remove(“A”)操作，查看remove(Object o)的源码： 12345678910111213141516171819202122232425public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125;private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意在fastRemove()方法中，执行了modCount++，而modCount属于其父类的成员变量，在前面我们说过，modCount是一种fail-fast机制，我们对modCount的值更改后，而Itr类的expectedModCount并没有发生改变，这时候我们进行下一次迭代时 checkForComodification() 就会抛出异常。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，切忌在迭代过程中直接对容器进行增删操作。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们接着探究一下迭代器是如何保证删除过程的顺利进行，查看其方法： 1234567891011121314public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最重要的操作有两步：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步：检查容器有没有发生改变；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二步，删除容器元素后，更新expectedModCount的值。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面的迭代器中，我们可以看到 Itr 有这样的特点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、单向&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、只能删除最后一个遍历过的元素。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于上面的迭代器并不能满足我们对容器的常用操作，为此Java又引入了一种新的迭代器 ListIterator。ArrayList同样可以使用ListIterator，其内部封装了内部类 ListItr，其继承关系图如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; //是否有前一个元素 public boolean hasPrevious() &#123; return cursor != 0; &#125; // 返回下一个元素索引 public int nextIndex() &#123; return cursor; &#125; // 返回前一个元素索引 public int previousIndex() &#123; return cursor - 1; &#125; // 返回前一个元素 @SuppressWarnings("unchecked") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; // 更改最后遍历元素的值 public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; // 在下一个要遍历元素的位置添加元素 public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在ListIterator中，依然调用了checkForComodification()，这代表我们依然不能直接对容器进行增删操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时ListIterator有以下特点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、双向&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、允许增加、删除 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、subList(int fromIndex, int toIndex)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定索引之间的元素集合（不包含最后一个索引的元素）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、sort(Comparator&lt;? super E&gt; c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们对容器进行排序时，需要给sort传入Comparator对象，指定我们的排序规则。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例： 1234567891011121314151617181920212223242526272829303132333435363738class Student&#123; String name; int score; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", score=" + score + '&#125;'; &#125; public Student(String name, int score) &#123; this.name = name; this.score = score; &#125; public static void main(String[] args) &#123; Student student1 = new Student("张三",89); Student student2 = new Student("李四",98); Student student3 = new Student("王五",66); List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.addAll(Arrays.asList(new Student[]&#123;student1, student2, student3&#125;)); System.out.println(list); //[Student&#123;name='张三', score=89&#125;, Student&#123;name='李四', score=98&#125;, Student&#123;name='王五', score=66&#125;] list.sort(new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; // 按成绩排序 return o1.score-o2.score; &#125; &#125;); System.out.println(list); //[Student&#123;name='王五', score=66&#125;, Student&#123;name='张三', score=89&#125;, Student&#123;name='李四', score=98&#125;] &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上便是对ArrayList的源码分析了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Collection</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础提高-四]]></title>
    <url>%2Fpost%2Fbe5f75ad.html</url>
    <content type="text"><![CDATA[(１)抽象类我们都知道类是根据实体对象抽象而来,以学生为例吧,我们抽取学生的特型,组合成学生类.而如果我们不断对类进行抽象,便又可以组合出抽象类. 1. 抽象类与普通类的区别 被abstract修饰 12public abstract class Person &#123;&#125; 不能被final修饰 可以不包含方法的实现体 12345public abstract class Person &#123; //如果方法被abstract修饰,说明这是一个抽象方法 public abstract void sayHello();&#125; 不能实例化 抽象类与普通类的区别除以上区别后,并没有其他区别,即普通类可以有的,抽象类同样可以拥有. 被abstract修饰的方法不能被final和private修饰,因为abstract方法其子类要去重写该方法,如果被final修饰,则不能重写该方法;被private修饰,除该类外,其他类不能访问该方法,更谈不上去重写该方法. 2.子类继承抽象类 子类继承抽象类方法同普通类一样,使用extends 1234567class Student extends Person&#123; @Override public void sayHello() &#123; System.out.println(getClass().getName()+":sayHello"); &#125;&#125; 子类没有重写抽象方法如果我们没有去重写其抽象方法,则其子类还是抽象类. 123abstract class Teacher extends Person&#123;&#125; 3. 抽象类不可以实例化,其构造器作用?示例代码如下: 1234567891011121314151617181920212223242526272829public abstract class Person &#123; public abstract void sayHello(); public Person()&#123; System.out.println("执行抽象类的构造方法"); &#125;&#125;class Student extends Person&#123; @Override public void sayHello() &#123; System.out.println(getClass().getName()+":sayHello"); &#125; public Student()&#123; System.out.println("执行非抽象类的构造方法"); &#125; public static void main(String[] args) &#123; Student student = new Student(); student.sayHello(); &#125;&#125; 输出如下: 执行抽象类的构造方法 执行非抽象类的构造方法 Student:sayHello 可以看出,在执行子类的构造器时,会执行抽象类的构造方法,所以抽象类的构造方法可以完成一些初始化操作. 4. 抽象类可以没有方法吗?可以. 作用:不让创建该类的对象. (2)接口由于继承类时,每个类只可以继承一个抽象类,而如果我们只想要增加一些功能,不想将这些方法添加到抽象类中,可以使用接口 inteface . 而 interface 与抽象类,我们更加关注其方法,可以说是比抽象类更加抽象. 1. 接口与抽象类的区别 接口中的方法默认为public权限. 在JDK1.8及以后,允许有方法体的方法,因为当我们给接口拓展方法时,其每一个实现类都要重写该方法,这样会很不便. 12345678910public interface MyInterface &#123; void a(); //如果方法具有方法体,且非静态方法,必须被default修饰 default void b()&#123; System.out.println("hello interface"); &#125;&#125; 接口没有构造方法 接口中的成员变量修饰符 修饰符 接口 抽象类 public YES YES protected NO YES default NO YES private NO YES 接口中的域同样是public的，同时且为static和final的。 2.一个类可以实现多个接口，却只能去继承一个类个人博客：https://wshuaigit.github.io]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>抽象类</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础提高(三)]]></title>
    <url>%2Fpost%2F9d02b266.html</url>
    <content type="text"><![CDATA[Java基础提高(三) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次开始介绍String类及其相关类，String首先声明这是一个引用类型。很多学习了一段时间Java的人依然认为这是一个基本类型，大概是因为像基本类型一样经常使用吧。但必须知道这并不是基本类型，而是引用类型，否则人家问你时不是闹了个笑话吗？ 1.String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么要介绍String，因为在我们的程序代码中，会经常用到String，而String存在一些知识盲区你可能并不了解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先要知道的是该类是一个final类，即你并不能去继承该类。为什么要这样设计？我个人有两点看法：（1）因为sun认为该类已经很完美了，不需要被继承；2）我们在传输数据时，大量的用到字符串，如果你继承String，却不能够严谨完善的实现其功能，容易造成数据不安全。 1public final class String &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其次，我们都知道String是一个不可变字符串，那么为什么是不可变字符串？是因为String数组内部封装了一个final数组？ 1private final char value[]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于被final修饰的引用类型，只是其地址值不可以改变，那么其数组下标中的元素可以改变吗？答案是可以的，如下所示： 12345678910111213141516171819202122232425public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; String s = "abcd"; //获得Class对象 Class c = s.getClass(); //让s1和s的地址相同，判断反射改变String的值后地址有没有发生变化 String s1 = s; //输出true System.out.println(s1 == s); //获得String的成员变量，即final数组 Field value = c.getDeclaredField("value"); //因为数组为private，所以需要取消语法检查 value.setAccessible(true); char[] array = (char[])value.get(s); //输出[a, b, c, d] System.out.println(Arrays.toString(array)); //输出abcd System.out.println(s); array[3] = 'a'; //[a, b, c, a] System.out.println(Arrays.toString(array)); //输出abca System.out.println(s); //输出true System.out.println(s1 == s); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意最后输出的是true，那么则说明地址并没有发生变化，我们确实改变了String的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么事情这么简单吗？如果我们打印hashCode会有变化吗？运行后发现hashCode的值并没有发生变化，这是为什么呢？要知道不在反射的情况下，这两个的字符串的hashCode并不相同？这是因为在我们创建String对象的时候，便已经计算了hashCode的值？如下： 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而我们在反射的过程中，并没有进行hashCode值的更新，所以如果要反射更换值时要更新hashCode，同时只能改变数组元素的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存在如下一组代码： 12345String s1 = "abc"; String s2 = "abc"; String s3 = new String("abc"); System.out.println(s1 == s2); System.out.println(s1 == s3); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出： 12truetrue &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是因为以非 new 的方式创建String时，首先到字符串常量池中查找目标字符串。若不存在，则在常量池中直接创建该字符串并返回引用。若存在，则直接返回返回引用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而执行到String s3 = new String(“abc”);时，我们每一次new时，都是在堆中创建对象，又因为字符串常量池已经存在目标值，所以内存图如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们使用new创建字符串时，如果目标串不在字符串常量池时，会将目标串加到字符串常量池中，然后继续在堆中分配内存。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里留下一个问题，即如果我们以下面这种方式创建字符串的话，那么会不会将字符串加入到常量池中？ 1String s = new String("a")+new String("b"); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先可以明确的知道”a”和”b”在字符串常量池中，那么”ab”在不在字符串常量池中呢？我们待会进行验证。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String类中存在这样一个方法intern() 123456789101112131415161718192021222324/** * Returns a canonical representation for the string object. * &lt;p&gt; * A pool of strings, initially empty, is maintained privately by the * class &#123;@code String&#125;. * &lt;p&gt; * When the intern method is invoked, if the pool already contains a * string equal to this &#123;@code String&#125; object as determined by * the &#123;@link #equals(Object)&#125; method, then the string from the pool is * returned. Otherwise, this &#123;@code String&#125; object is added to the * pool and a reference to this &#123;@code String&#125; object is returned. * &lt;p&gt; * It follows that for any two strings &#123;@code s&#125; and &#123;@code t&#125;, * &#123;@code s.intern() == t.intern()&#125; is &#123;@code true&#125; * if and only if &#123;@code s.equals(t)&#125; is &#123;@code true&#125;. * &lt;p&gt; * All literal strings and string-valued constant expressions are * interned. String literals are defined in section 3.10.5 of the * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;. * * @return a string that has the same contents as this string, but is * guaranteed to be from a pool of unique strings. */ public native String intern(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从注释可知，当我们调用这个方法时，如果常量池中存在和目标串相同的值，则返回常量池中的地址。否则，直接返回引用，并且将目标串加入到字符串常量池中。示例如下： 1234String s1 = new String("ab"); String s2 = s1.intern(); System.out.println(s1 == s2); // 输出：false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存图如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以这里输出的是false。现在回到我们上面的问题，当我们以 + 进行字符串拼接时会不会加入到字符串常量池中？示例代码如下： 1234String s1 = new String("a") + new String("b"); String s2 = s1.intern(); System.out.println(s1 == s2); // 输出：true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即我们在执行String s1 = new String(“a”) + new String(“b”);并不会将”ab”加入到字符串常量池中。 2.StringBuilder &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;正是由于String是不可变字符串，我们对String的每一次修改操作都产生了新的String。这样有时不符合我们的需求，所以便又产生了可变字符串。StringBuilder和StringBuffer。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要声明的便是StringBuild是可变字符串，接着我们开始研究其源码。通过观察源码后，发现StringBuild通过继承AbstractStringBuilder获得其成员变量，而AbstractStringBuilder存在一个char数组。 12345678910abstract class AbstractStringBuilder implements Appendable, CharSequence &#123; /** * The value is used for character storage. */ char[] value; /** * The count is the number of characters used. */ int count; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们创建StringBuild数组时，默认创建一个长度为16的字符数组。 123public StringBuilder() &#123; super(16); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们给StringBuild添加元素时，有人认为是将整体放入数组中的下标，通过观察源码这是并不是正确。如下： 123StringBuilder sb = new StringBuilder(); sb.append(123); System.out.println(sb.length()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并不是将123整个放入数组中的元素，而是分割开,分别放入数组中的元素。 3.StringBuffer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你观察StringBuffer的源码，发现StringBuilder的差别几乎没有，唯一的大区别大概就是StringBuffer中的方法被synchronized，而synchronized的作用就是为了保证线程安全。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是线程安全问题？即多个线程同时对一份资源进行读写操作（注意：只进行读操作并不会产生线程安全问题），这样会导致数据混乱。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而在多线程环境下，我们可以通过synchronized实现每次对一份资源进行读写操作只有一个线程执行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以StringBuffer与StringBuild最大的区别就是线程是否安全。 类 是否线程安全 是否可变 String 安全 不可变 StringBuilder 不安全 可变 StringBuffer 安全 可变 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;个人博客：https://wshuaigit.github.io/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础提高(二)]]></title>
    <url>%2Fpost%2Fe3f1924d.html</url>
    <content type="text"><![CDATA[Java基础提高(二)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继续上次的内容，现在开始介绍Java中经常被使用的类，你不得不了解的类。 1. Object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道，Java是一门面向对象的语言，而面向对象的三大特征是：封装、继承、多态。在继承中，如果我们没有直接声明一个类的父类，那么这个类的父类便是Object。所以Object类可以算是所有类的祖宗类，这便是我们不得不关注该类的原因。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们开始进行该类方法的介绍： 权限 方法名 作用 private registerNatives() 让JVM找到本地方法 public getClass() 获得Class对象 public hashCode() 获得哈希值 public equals(Object obj) 比较两个对象是否相等 protected clone() 克隆对象 public toString() 打印该对象的信息 public notify() 唤醒一个等待中的线程 public notifyAll() 唤醒多个等待中的线程 public wait() 让当前线程等待，并释放锁 public wait(long timeout) 让当前线程等待，直到指定时间或被唤醒 public wait(long timeout, int nanos) 同wait(long timeout)，time = 1000000*timeout+nanos protected finalize() 被垃圾回收器清除之前执行 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、在该类中，我们可以看到有一些方法被native修饰，那么为什么这些方法要被native修饰呢？我们都知道任意一种语言都希望效率越高越好，如C语言，经历了这么多年依然很流行，正是由于其与底层最接近。而面向对象的语言很难像C语言一样高效，为了在其他语言中使用C语言，便产生了native method.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、每一个类都有一个其对应的Class对象，该对象被保存在一个同名的.class文件中。通过该Class对象，我们可以创建对象。通过该对象，我们可以获得该类的任意信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、在数组中，我们如果要寻找一个元素，如果不知道该元素的下标，那么便只能所数组头部进行搜索，这样造成的后果便是查找元素慢。倘若我们一开始就知道该元素的下标，那么我们只要找数组指定下标元素，这样效率是不是很高？而哈希值的原理便是基于此，存在这样一张哈希表，我们通过哈希值可以快速找到目标元素。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈希值的常用算法：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)直接定址法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)数字分析法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3)平方取中法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4)折叠法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5)除留余数法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(6)随机数法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是不是存在这样的疑惑？为什么需要这么多种计算方法？一种不就够了吗？这是因为对于不同类，肯定都是不相同的，那么所有的类都使用一种方法的话肯定是很不合适的。我们应该就可能避免哈希值相同的情况。 123456789@Test public void test()&#123; String s1 = &quot;通话&quot;; String s2 = &quot;重地&quot;; System.out.println(s1.hashCode()); //输出：1179395 System.out.println(s2.hashCode()); //输出：1179395 &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上面可以看出，不同的对象可能会产生相同的哈希值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、有时候我们需要判断两个对象是否相等，那么这个时候就需要重写equal(Object o)方法。如下存在这样一个类： 12345678910111213public class Student &#123; private int age; private String name; public Student()&#123; super(); &#125; public Student(int age,String name)&#123; this.age = age; this.name = name; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要判断这两个对象是否值相等，可以这样做： 123456public static void main(String[] args) &#123; Student s1 = new Student(20,&quot;张三&quot;); Student s2 = new Student(20,&quot;张三&quot;); System.out.println(s1.equals(s2)); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案是false，为什么两个对象值相等，比较或却是false呢？因为我们没有重写equals(Object o)方法，调用的是父类Object的方法,代码如下： 123public boolean equals(Object obj) &#123; return (this == obj); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于两个对象都是在堆中new出的，所以他们有不同的地址，而==对于引用类型来说比较的是地址，所以答案是false。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么我们不想比较地址，就只能重写equals方法了，如下： 123456789101112131415161718@Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; &#125; @Override public int hashCode() &#123; int result = age; result = 31 * result + (name != null ? name.hashCode() : 0); return result; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常来说，我们会同时重写equlas方法和hashCode方法。哈希值相等但不一定是同一个对象，同一个对象一定哈希值相等。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、克隆对象，以上面的类为例，我们要使用clone()方法需实现 Cloneable 接口。 123456public static void main(String[] args) throws CloneNotSupportedException &#123; Student s1 = new Student(20,&quot;张三&quot;); Student s2 = (Student)s1.clone(); System.out.println(s1 == s2 ); System.out.println(s1.equals(s2)); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出如下：false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出，clone方法只是将值复制过去，地址并不相同。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6、打印对象的信息，如果我们直接输出对象，调用toString()方法。如下： 12Student s1 = new Student(20,&quot;张三&quot;); System.out.println(s1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出：Student@bd555&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们不重写toString()的话，默认调用父类的toString()。代码如下： 123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认为：类名 + @ + 十六进制哈希值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：很多人认为hashCode的值就是地址值，这一说法并不完全正确，因为在我们进行hashCode方法重写时，哈希算法由我们自己写，我们怎么可能决定内存地址呢？但是对于Object类来说，确实时将地址转为int值。 1234(This is typically implemented by converting the internaladdress of the object into an integer, but this implementationtechnique is not required by theJava&amp;trade; programming language.) 7、在C语言中，如果我们想要释放内存的话，必须手动进行释放。但是Java简化了这一过程，由垃圾回收器替我们完成。而重写finalize()后，当垃圾回收器清理没有被引用的对象时，会执行该方法。 1234@Override protected void finalize() throws Throwable &#123; System.out.println(&quot;执行finalize()方法&quot;); &#125; 1234567public static void main(String[] args) throws CloneNotSupportedException &#123; new Student(20,&quot;张三&quot;); new Student(20,&quot;张三&quot;); new Student(20,&quot;张三&quot;); System.gc();&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用该方法后，可能会有如下输出： 123执行finalize()方法执行finalize()方法执行finalize()方法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果并没有进行输出的话，也很正常，尝试多运行几次。因为System.gc()的作用只是提醒虚拟机应该进行清理垃圾了，但虚拟机并不一定会听取。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与线程相关的方法在后期详细介绍。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--简单工厂模式]]></title>
    <url>%2Fpost%2Fbb9a1e1b.html</url>
    <content type="text"><![CDATA[简单工厂模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相信很多人都听过设计模式吧，但是也只是局限于听说。很多人认为设计模式并没啥用啊（当然也包括我），我自己写的代码也可以完成需求，为啥还要设计模式呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在你学习之后会感叹代码还可以这么写，同时也能够更加熟练的运用面向对象的思想。本系列的文章来源于《大话设计模式》，感兴趣的朋友们可以找来阅读一番，很不错的一本书。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接开始正文吧，我们要实现两个数的运算，用户输入两个数字和一个操作符后，返回运算结果。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相信各位能够很容易实现该代码如下： 1234567891011121314151617181920212223public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入数字A:&quot;); String strNumA = scanner.nextLine(); System.out.print(&quot;请输入数字B:&quot;); String strNumB = scanner.nextLine(); System.out.println(&quot;请输入运算符:&quot;); String strOper = scanner.nextLine(); if(&quot;+&quot;.equals(strOper))&#123; System.out.println(Double.parseDouble(strNumA) + Double.parseDouble(strNumB)); &#125; if(&quot;-&quot;.equals(strOper))&#123; System.out.println(Double.parseDouble(strNumA) - Double.parseDouble(strNumB)); &#125; if(&quot;*&quot;.equals(strOper))&#123; System.out.println(Double.parseDouble(strNumA) * Double.parseDouble(strNumB)); &#125; if(&quot;/&quot;.equals(strOper))&#123; System.out.println(Double.parseDouble(strNumA) / Double.parseDouble(strNumB)); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我们可以发现，该段代码依然有很多问题，如：用户输入非法值时，我们没有进行异常处理；其次，当进行除法运算时，除数为0的话，我们也并没有进行判断；接着不断我输入哪个运算符，四个if语句都执行了，虽然说计算机运算速度，但是我们写出精炼的代码，能够让别人感觉到你的代码水平较高。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;改进后的代码如下： 1234567891011121314151617181920212223242526272829303132333435public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入数字A:&quot;); String strNumA = scanner.nextLine(); System.out.print(&quot;请输入数字B:&quot;); String strNumB = scanner.nextLine(); System.out.print(&quot;请输入运算符:&quot;); String strOper = scanner.nextLine(); try &#123; double result = 0; if (&quot;+&quot;.equals(strOper)) &#123; result = Double.parseDouble(strNumA) + Double.parseDouble(strNumB); &#125; else if (&quot;-&quot;.equals(strOper)) &#123; result = Double.parseDouble(strNumA) - Double.parseDouble(strNumB); &#125; else if (&quot;*&quot;.equals(strOper)) &#123; result = Double.parseDouble(strNumA) * Double.parseDouble(strNumB); &#125; else if (&quot;/&quot;.equals(strOper)) &#123; if(Double.parseDouble(strNumB)!=0) result = Double.parseDouble(strNumA) / Double.parseDouble(strNumB); else System.out.println(&quot;除数不能为0!&quot;); &#125;else&#123; System.out.println(&quot;请输入指定运算符!&quot;); return; &#125; System.out.println(&quot;运算结果:&quot;+result); &#125;catch (NumberFormatException e)&#123; System.out.println(&quot;请输入合法值!&quot;); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;观察上面的代码后，是不是觉得你写的代码已经很完善了，但是这是一个完全面向过程的程序吧。面向对象的三大特征封装、继承、多态好像并没有使用吧。该段程序的耦合度很高，高质量的程序应该是耦合度很低的，所以我们应该将业务逻辑与业务逻辑无关的分离，降低彼此之间的耦合度。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Operation &#123; public static double getResult(double numA,double numB,String oper) throws Exception &#123; double result = 0; switch (oper)&#123; case &quot;+&quot;: result = numA + numB; break; case &quot;-&quot;: result = numA - numB; break; case &quot;*&quot;: result = numA * numB; break; case &quot;/&quot;: if(numB != 0) &#123; result = numA / numB; &#125;else&#123; throw new Exception(&quot;除数不能为0!&quot;); &#125; break; default: throw new Exception(&quot;请输入指定运算符!&quot;); &#125; return result; &#125;&#125;public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入数字A:&quot;); String strNumA = scanner.nextLine(); System.out.print(&quot;请输入数字B:&quot;); String strNumB = scanner.nextLine(); System.out.print(&quot;请输入运算符:&quot;); String strOper = scanner.nextLine(); try &#123; double result = Operation.getResult(Double.parseDouble(strNumA),Double.parseDouble(strNumB),strOper); System.out.println(&quot;运算结果：&quot;+result); &#125;catch (NumberFormatException e)&#123; System.out.println(&quot;请输入合法值!&quot;); &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如此一来，我们便将调用者与业务逻辑之间进行了解耦和。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，如果我们要增加其他运算呢？如求平方根，求次方的话会怎么做？相信大家的想法是在Operation类中增加case语句不就好了吗？但是这样做的话，我们得更改原程序的代码。通常来说，是很忌讳直接去修改原程序的代码。这时，我们就可以运用面向对象的其他特征了。12345678910111213141516171819202122232425262728293031323334353637383940public abstract class Operation &#123; public abstract double getResult(double numA,double numB) throws Exception;&#125;class OperAdd extends Operation&#123; @Override public double getResult(double numA, double numB) &#123; return numA + numB; &#125;&#125;class OperSub extends Operation&#123; @Override public double getResult(double numA, double numB) &#123; return numA - numB; &#125;&#125;class OperMul extends Operation&#123; @Override public double getResult(double numA, double numB) &#123; return numA * numB; &#125;&#125;class OperDiv extends Operation&#123; @Override public double getResult(double numA, double numB) throws Exception &#123; if(numB == 0) throw new Exception(&quot;除数不能为0!&quot;); return numA / numB; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通过判断运算符的类型，继承父类生成合适的子类对象，利用多态即可。这样的话，当需要其他功能时，我们只需要继续去继承父类即可。而我们生成合适子类的过程中便用到了简单工厂模式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单工厂模式示例代码如下： 12345678910111213141516171819202122public class OperFactory &#123; public Operation createOper(String oper) throws Exception &#123; Operation operation = null; switch (oper)&#123; case &quot;+&quot;: operation = new OperAdd(); break; case &quot;-&quot;: operation = new OperSub(); break; case &quot;*&quot;: operation = new OperMul(); break; case &quot;/&quot;: operation = new OperDiv(); break; default: throw new Exception(&quot;请输入指定运算符&quot;); &#125; return operation; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们进行运算时，让工厂产生合适的子类对象，这样我们就可以进行运算了。123456789101112131415161718192021222324252627public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入数字A:&quot;); String strNumA = scanner.nextLine(); System.out.print(&quot;请输入数字B:&quot;); String strNumB = scanner.nextLine(); System.out.print(&quot;请输入运算符:&quot;); String strOper = scanner.nextLine(); try &#123; //生成工厂对象 OperFactory factory = new OperFactory(); //生成合适的子类对象 Operation oper = factory.createOper(strOper); //利用多态进行计算 double result = oper.getResult(Double.parseDouble(strNumA),Double.parseDouble(strNumB)); System.out.println(&quot;运算结果:&quot;+result); &#125;catch (NumberFormatException e)&#123; System.out.println(&quot;请输入合法数字！&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个OperFactory像不像一个工厂呢？如饮料厂生产饮料，根据用户的需求去生产合适的饮料。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能还挺过静态工厂模式，那么什么时静态工厂呢？很简单，不过是将生产子类的方法由对象方法提升至类方法，这样我们就可以不用生成工厂对象，直接通过类去调用该方法即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习了简单工厂模式后，我们总结一下什么时候时候该设计模式，首先对需求进行分习，如上可以分离出一个抽象类：运算类。然后该类的方法在不同的条件下有不同的执行过程。那么，此时我们便可以使用简单工厂模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础提高(一)]]></title>
    <url>%2Fpost%2F4cc0092f.html</url>
    <content type="text"><![CDATA[Java基础提高（一）最近开始Java的复习，弥补一下从前的知识盲区且深入底层去学习Java，通过了解源码更加深入的去了解Java。 1.面向过程和面向对象的区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道C语言是一门完全面向过程的语言，当我们要是实现某些需求时，我们更在意的是如何通过一个函数去实现该需求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而在Java中我们更加在意的是对象，哪些对象拥有哪些功能。当我们面对一个需求时，让这些对象去实现某些需求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以将大象装入冰箱为例，面向过程我们可能会这样做：我们把冰箱门打开，我们把大象装进冰箱，我们把冰箱关闭。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而面向对象我们可能会这样做：首先进行分析，该需求有两个对象，冰箱和大象。冰箱有如下功能：打开、关闭。大象有如下功能：走到冰箱中。实现该需求过程如下：冰箱开门，大象走进冰箱，冰箱关门。 显而易见：面向过程更加在意的是我们实现这个需求的过程，而面向对象则是通过对对象的分析，让其他对象去完成该需求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你刚接触Java，可能并不能体会到什么叫面向对象，比如我们写一个方法，你觉得这个实现过程和面向过程的实现并没有区别。这是因为面向对象只是在宏观上是面向对象，微观上依然是面向过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，面向过程是我们自己去做，面向对象是让别人去做。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然面向面向并不仅仅局限于此，其三大特征为：封装、继承、多态。 2.JDK和JRE的区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDK是Java程序的开发包，而Jre只是Java程序的运行环境。JDK包含了Jre，JDK中的bin目录中有如下程序javac.exejava.exe,javap.exe等,javac用于编译Java程序的源代码，生成字节码文件；java用于运行编译后的字节码文件，javap用于反编译，可以查看编译后的指令等。 3.基本数据类型和包装类型 基本数据类型 包装类型 字节 boolean Boolean - byte Byte 1 short Short 2 char Character 2 int Integer 4 float Float 4 double Double 8 long Long 8 void Void - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、boolean类型所占的存储空间的大小没有明确知道，仅定义为能够取字面值true或false。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、一个boolean变量在编译后以一个int代替，一个boolean数组编译后，数组中每个成员是一个byte。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、《Java编程思想》中将void列为基本类型，但是其他资料并没有认为void是基本类型，Void的源码中说明该类是一个占位符类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、在Java中，认为一切皆对象，但是由于基本类型并不是对象，便引入了包装类型，实现基本类型和包装类型的相互转化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、基本类型和包装类型的区别：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(一)初值不同，如boolean的初值为false,int的初值为0，而包装类型的初值为null(注意：这里的初值是位于类中的成员变量而不是方法中的变量，方法中的变量必须赋初值才能使用)；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(二)存储位置不同，基本类型存储位置在栈中，而包装类型的存储位置位于堆中；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(三)在与集合类共同使用时，必须使用包装类型。 4.自动装箱和拆箱&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDK1.5后引入了自动装箱和拆箱，从而实现基本类型和包装类型的自动转换。自动装箱调用的是valueOf()方法，而自动拆箱调用的是(基本类型+Value())方法，例如Integer实现自动拆箱调用的是intValue()。 1234567Integer a = 1; Integer b = 1; System.out.println(a == b); Integer c = new Integer(1); Integer d = new Integer(1); System.out.println(c == d); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行段代码后，输出应该为： 12truefalse &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是因为 == 比较的是地址，而Integer存在缓存池，进行自动装箱且值位于-128 - 127时，从缓存池中返回对应的Integer的引用，所以a,b的引用相同。而c、d并没有进行自动装箱，而是自己在堆中 new 对象，每个对象的引用。 12345678public static Integer valueOf(int i) &#123; // IntegerCache.low = -128; // IntegerCache.high; high的值默认为127 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) IntegerCache.cache[] 是一个Integer数组，包含了 low到high 的引用 return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么对于其他的包装类型，是否也同样有缓存池呢？ 1234567Boolean a = true;Boolean b = true;System.out.println(a == b);Boolean c = new Boolean(true);Boolean d = new Boolean(true);System.out.println(c == d); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出结果如下： 12truefalse &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过观察源码，发现类中有这样两个常量：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们进行自动装箱时，返回这两个对象的引用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再来看看其他的包装类： 123Double a = 1.0;Double b = 1.0;System.out.println(a == b); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;猜测一下答案吧，可能会有点出乎你的意料，答案是： 1true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这当然是因为并不存在缓存池了，想想也是。对于浮点型，要创建它的缓存池好像也做不到吧。 包装类型 是否存在缓存池 范围 Boolean 不存在，但是存在两个常量 Byte 存在 -127 - 128 Short 存在 -127 - 128 Charcater 存在 0 - 127 Integer 存在 -127 - 128 Float 不存在 Double 不存在 Long 存在 -127 - 128 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是Integer缓存池的上限可以我们自己定义，但是不能超过127，而其他包装类型的范围都是已经确定了的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不知道你有没有写过这样的代码？将一个int直接自动装箱为Double。如果没有的话，可以去尝试一下，结果可能会出乎你的意料。 1234567public static void main(String[] args) &#123; Double a = 1; Double b = new Double(1);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上所示，你可能会认为Double自动装箱的话调vlaueOf(double d)那么的话，我的1可以自动类型转换为1.0，那我当然可以实现自动装箱了，然而编译结果如下： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以这样理解，自动装箱的过程中关闭了自动类型转换。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
