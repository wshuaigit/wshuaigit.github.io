<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础提高(二)]]></title>
    <url>%2Fpost%2Fe3f1924d.html</url>
    <content type="text"><![CDATA[Java基础提高(二)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继续上次的内容，现在开始介绍Java中经常被使用的类，你不得不了解的类。 1. Object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道，Java是一门面向对象的语言，而面向对象的三大特征是：封装、继承、多态。在继承中，如果我们没有直接声明一个类的父类，那么这个类的父类便是Object。所以Object类可以算是所有类的祖宗类，这便是我们不得不关注该类的原因。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们开始进行该类方法的介绍：| 权限 | 方法名 | 作用 ||–|–|–|| private | registerNatives() | 让JVM找到本地方法 || public | getClass() | 获得Class对象 || public | hashCode() | 获得哈希值 || public | equals(Object obj)| 比较两个对象是否相等 || protected | clone() | 克隆对象 || public | toString() | 打印该对象的信息 || public | notify() | 唤醒一个等待中的线程 || public | notifyAll() | 唤醒多个等待中的线程 || public | wait()| 让当前线程等待，并释放锁 || public | wait(long timeout) | 让当前线程等待，直到指定时间或被唤醒 || public | wait(long timeout, int nanos) | 同wait(long timeout)，time = 1000000*timeout+nanos|| protected | finalize() | 被垃圾回收器清除之前执行 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、在该类中，我们可以看到有一些方法被native修饰，那么为什么这些方法要被native修饰呢？我们都知道任意一种语言都希望效率越高越好，如C语言，经历了这么多年依然很流行，正是由于其与底层最接近。而面向对象的语言很难像C语言一样高效，为了在其他语言中使用C语言，便产生了native method.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、每一个类都有一个其对应的Class对象，该对象被保存在一个同名的.class文件中。通过该Class对象，我们可以创建对象。通过该对象，我们可以获得该类的任意信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、在数组中，我们如果要寻找一个元素，如果不知道该元素的下标，那么便只能所数组头部进行搜索，这样造成的后果便是查找元素慢。倘若我们一开始就知道该元素的下标，那么我们只要找数组指定下标元素，这样效率是不是很高？而哈希值的原理便是基于此，存在这样一张哈希表，我们通过哈希值可以快速找到目标元素。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈希值的常用算法：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)直接定址法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)数字分析法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3)平方取中法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4)折叠法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5)除留余数法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(6)随机数法；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是不是存在这样的疑惑？为什么需要这么多种计算方法？一种不就够了吗？这是因为对于不同类，肯定都是不相同的，那么所有的类都使用一种方法的话肯定是很不合适的。我们应该就可能避免哈希值相同的情况。 123456789@Test public void test()&#123; String s1 = &quot;通话&quot;; String s2 = &quot;重地&quot;; System.out.println(s1.hashCode()); //输出：1179395 System.out.println(s2.hashCode()); //输出：1179395 &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上面可以看出，不同的对象可能会产生相同的哈希值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、有时候我们需要判断两个对象是否相等，那么这个时候就需要重写equal(Object o)方法。如下存在这样一个类： 12345678910111213public class Student &#123; private int age; private String name; public Student()&#123; super(); &#125; public Student(int age,String name)&#123; this.age = age; this.name = name; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们要判断这两个对象是否值相等，可以这样做： 123456public static void main(String[] args) &#123; Student s1 = new Student(20,&quot;张三&quot;); Student s2 = new Student(20,&quot;张三&quot;); System.out.println(s1.equals(s2)); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案是false，为什么两个对象值相等，比较或却是false呢？因为我们没有重写equals(Object o)方法，调用的是父类Object的方法,代码如下： 123public boolean equals(Object obj) &#123; return (this == obj); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于两个对象都是在堆中new出的，所以他们有不同的地址，而==对于引用类型来说比较的是地址，所以答案是false。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么我们不想比较地址，就只能重写equals方法了，如下： 123456789101112131415161718@Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; &#125; @Override public int hashCode() &#123; int result = age; result = 31 * result + (name != null ? name.hashCode() : 0); return result; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常来说，我们会同时重写equlas方法和hashCode方法。哈希值相等但不一定是同一个对象，同一个对象一定哈希值相等。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、克隆对象，以上面的类为例，我们要使用clone()方法需实现 Cloneable 接口。 123456public static void main(String[] args) throws CloneNotSupportedException &#123; Student s1 = new Student(20,&quot;张三&quot;); Student s2 = (Student)s1.clone(); System.out.println(s1 == s2 ); System.out.println(s1.equals(s2)); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出如下：false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出，clone方法只是将值复制过去，地址并不相同。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6、打印对象的信息，如果我们直接输出对象，调用toString()方法。如下： 12Student s1 = new Student(20,&quot;张三&quot;); System.out.println(s1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出：Student@bd555&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们不重写toString()的话，默认调用父类的toString()。代码如下： 123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认为：类名 + @ + 十六进制哈希值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：这里的十六进制值并不是该对象在内存中的值，很多人认为这是地址值，哈希算法由我们自己写，我们怎么可能决定内存地址呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7、在C语言中，如果我们想要释放内存的话，必须手动进行释放。但是Java简化了这一过程，由垃圾回收器替我们完成。而重写finalize()后，当垃圾回收器清理没有被引用的对象时，会执行该方法。 1234@Override protected void finalize() throws Throwable &#123; System.out.println(&quot;执行finalize()方法&quot;); &#125; 1234567public static void main(String[] args) throws CloneNotSupportedException &#123; new Student(20,&quot;张三&quot;); new Student(20,&quot;张三&quot;); new Student(20,&quot;张三&quot;); System.gc();&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用该方法后，可能会有如下输出： 123执行finalize()方法执行finalize()方法执行finalize()方法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果并没有进行输出的话，也很正常，尝试多运行几次。因为System.gc()的作用只是提醒虚拟机应该进行清理垃圾了，但虚拟机并不一定会听取。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与线程相关的方法在后期详细介绍。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础提高(一)]]></title>
    <url>%2Fpost%2F4cc0092f.html</url>
    <content type="text"><![CDATA[Java基础提高（一）最近开始Java的复习，弥补一下从前的知识盲区且深入底层去学习Java，通过了解源码更加深入的去了解Java。 1.面向过程和面向对象的区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道C语言是一门完全面向过程的语言，当我们要是实现某些需求时，我们更在意的是如何通过一个函数去实现该需求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而在Java中我们更加在意的是对象，哪些对象拥有哪些功能。当我们面对一个需求时，让这些对象去实现某些需求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以将大象装入冰箱为例，面向过程我们可能会这样做：我们把冰箱门打开，我们把大象装进冰箱，我们把冰箱关闭。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而面向对象我们可能会这样做：首先进行分析，该需求有两个对象，冰箱和大象。冰箱有如下功能：打开、关闭。大象有如下功能：走到冰箱中。实现该需求过程如下：冰箱开门，大象走进冰箱，冰箱关门。 显而易见：面向过程更加在意的是我们实现这个需求的过程，而面向对象则是通过对对象的分析，让其他对象去完成该需求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你刚接触Java，可能并不能体会到什么叫面向对象，比如我们写一个方法，你觉得这个实现过程和面向过程的实现并没有区别。这是因为面向对象只是在宏观上是面向对象，微观上依然是面向过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，面向过程是我们自己去做，面向对象是让别人去做。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然面向面向并不仅仅局限于此，其三大特征为：封装、继承、多态。 2.JDK和JRE的区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDK是Java程序的开发包，而Jre只是Java程序的运行环境。JDK包含了Jre，JDK中的bin目录中有如下程序javac.exejava.exe,javap.exe等,javac用于编译Java程序的源代码，生成字节码文件；java用于运行编译后的字节码文件，javap用于反编译，可以查看编译后的指令等。 3.基本数据类型和包装类型 基本数据类型 包装类型 字节 boolean Boolean - byte Byte 1 short Short 2 char Character 2 int Integer 4 float Float 4 double Double 8 long Long 8 void Void - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说明：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、boolean类型所占的存储空间的大小没有明确知道，仅定义为能够取字面值true或false。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、一个boolean变量在编译后以一个int代替，一个boolean数组编译后，数组中每个成员是一个byte。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、《Java编程思想》中将void列为基本类型，但是其他资料并没有认为void是基本类型，Void的源码中说明该类是一个占位符类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、在Java中，认为一切皆对象，但是由于基本类型并不是对象，便引入了包装类型，实现基本类型和包装类型的相互转化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、基本类型和包装类型的区别：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(一)初值不同，如boolean的初值为false,int的初值为0，而包装类型的初值为null(注意：这里的初值是位于类中的成员变量而不是方法中的变量，方法中的变量必须赋初值才能使用)；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(二)存储位置不同，基本类型存储位置在栈中，而包装类型的存储位置位于堆中；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(三)在与集合类共同使用时，必须使用包装类型。 4.自动装箱和拆箱&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDK1.5后引入了自动装箱和拆箱，从而实现基本类型和包装类型的自动转换。自动装箱调用的是valueOf()方法，而自动拆箱调用的是(基本类型+Value())方法，例如Integer实现自动拆箱调用的是intValue()。 1234567Integer a = 1; Integer b = 1; System.out.println(a == b); Integer c = new Integer(1); Integer d = new Integer(1); System.out.println(c == d); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行段代码后，输出应该为： 12truefalse &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是因为 == 比较的是地址，而Integer存在缓存池，进行自动装箱且值位于-128 - 127时，从缓存池中返回对应的Integer的引用，所以a,b的引用相同。而c、d并没有进行自动装箱，而是自己在堆中 new 对象，每个对象的引用。 12345678public static Integer valueOf(int i) &#123; // IntegerCache.low = -128; // IntegerCache.high; high的值默认为127 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) IntegerCache.cache[] 是一个Integer数组，包含了 low到high 的引用 return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么对于其他的包装类型，是否也同样有缓存池呢？ 1234567Boolean a = true;Boolean b = true;System.out.println(a == b);Boolean c = new Boolean(true);Boolean d = new Boolean(true);System.out.println(c == d); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出结果如下： 12truefalse &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过观察源码，发现类中有这样两个常量：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们进行自动装箱时，返回这两个对象的引用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再来看看其他的包装类： 123Double a = 1.0;Double b = 1.0;System.out.println(a == b); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;猜测一下答案吧，可能会有点出乎你的意料，答案是： 1true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这当然是因为并不存在缓存池了，想想也是。对于浮点型，要创建它的缓存池好像也做不到吧。 包装类型 是否存在缓存池 范围 Boolean 不存在，但是存在两个常量 Byte 存在 -127 - 128 Short 存在 -127 - 128 Charcater 存在 0 - 127 Integer 存在 -127 - 128 Float 不存在 Double 不存在 Long 存在 -127 - 128 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是Integer缓存池的上限可以我们自己定义，但是不能超过127，而其他包装类型的范围都是已经确定了的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不知道你有没有写过这样的代码？将一个int直接自动装箱为Double。如果没有的话，可以去尝试一下，结果可能会出乎你的意料。 1234567public static void main(String[] args) &#123; Double a = 1; Double b = new Double(1);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上所示，你可能会认为Double自动装箱的话调vlaueOf(double d)那么的话，我的1可以自动类型转换为1.0，那我当然可以实现自动装箱了，然而编译结果如下： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以这样理解，自动装箱的过程中关闭了自动类型转换。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--简单工厂模式]]></title>
    <url>%2Fpost%2F4cc0092f.html</url>
    <content type="text"><![CDATA[简单工厂模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相信很多人都听过设计模式吧，但是也只是局限于听说。很多人认为设计模式并没啥用啊（当然也包括我），我自己写的代码也可以完成需求，为啥还要设计模式呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在你学习之后会感叹代码还可以这么写，同时也能够更加熟练的运用面向对象的思想。本系列的文章来源于《大话设计模式》，感兴趣的朋友们可以找来阅读一番，很不错的一本书。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接开始正文吧，我们要实现两个数的运算，用户输入两个数字和一个操作符后，返回运算结果。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相信各位能够很容易实现该代码如下： 1234567891011121314151617181920212223public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入数字A:&quot;); String strNumA = scanner.nextLine(); System.out.print(&quot;请输入数字B:&quot;); String strNumB = scanner.nextLine(); System.out.println(&quot;请输入运算符:&quot;); String strOper = scanner.nextLine(); if(&quot;+&quot;.equals(strOper))&#123; System.out.println(Double.parseDouble(strNumA) + Double.parseDouble(strNumB)); &#125; if(&quot;-&quot;.equals(strOper))&#123; System.out.println(Double.parseDouble(strNumA) - Double.parseDouble(strNumB)); &#125; if(&quot;*&quot;.equals(strOper))&#123; System.out.println(Double.parseDouble(strNumA) * Double.parseDouble(strNumB)); &#125; if(&quot;/&quot;.equals(strOper))&#123; System.out.println(Double.parseDouble(strNumA) / Double.parseDouble(strNumB)); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我们可以发现，该段代码依然有很多问题，如：用户输入非法值时，我们没有进行异常处理；其次，当进行除法运算时，除数为0的话，我们也并没有进行判断；接着不断我输入哪个运算符，四个if语句都执行了，虽然说计算机运算速度，但是我们写出精炼的代码，能够让别人感觉到你的代码水平较高。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;改进后的代码如下： 1234567891011121314151617181920212223242526272829303132333435public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入数字A:&quot;); String strNumA = scanner.nextLine(); System.out.print(&quot;请输入数字B:&quot;); String strNumB = scanner.nextLine(); System.out.print(&quot;请输入运算符:&quot;); String strOper = scanner.nextLine(); try &#123; double result = 0; if (&quot;+&quot;.equals(strOper)) &#123; result = Double.parseDouble(strNumA) + Double.parseDouble(strNumB); &#125; else if (&quot;-&quot;.equals(strOper)) &#123; result = Double.parseDouble(strNumA) - Double.parseDouble(strNumB); &#125; else if (&quot;*&quot;.equals(strOper)) &#123; result = Double.parseDouble(strNumA) * Double.parseDouble(strNumB); &#125; else if (&quot;/&quot;.equals(strOper)) &#123; if(Double.parseDouble(strNumB)!=0) result = Double.parseDouble(strNumA) / Double.parseDouble(strNumB); else System.out.println(&quot;除数不能为0!&quot;); &#125;else&#123; System.out.println(&quot;请输入指定运算符!&quot;); return; &#125; System.out.println(&quot;运算结果:&quot;+result); &#125;catch (NumberFormatException e)&#123; System.out.println(&quot;请输入合法值!&quot;); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;观察上面的代码后，是不是觉得你写的代码已经很完善了，但是这是一个完全面向过程的程序吧。面向对象的三大特征封装、继承、多态好像并没有使用吧。该段程序的耦合度很高，高质量的程序应该是耦合度很低的，所以我们应该将业务逻辑与业务逻辑无关的分离，降低彼此之间的耦合度。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Operation &#123; public static double getResult(double numA,double numB,String oper) throws Exception &#123; double result = 0; switch (oper)&#123; case &quot;+&quot;: result = numA + numB; break; case &quot;-&quot;: result = numA - numB; break; case &quot;*&quot;: result = numA * numB; break; case &quot;/&quot;: if(numB != 0) &#123; result = numA / numB; &#125;else&#123; throw new Exception(&quot;除数不能为0!&quot;); &#125; break; default: throw new Exception(&quot;请输入指定运算符!&quot;); &#125; return result; &#125;&#125;public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入数字A:&quot;); String strNumA = scanner.nextLine(); System.out.print(&quot;请输入数字B:&quot;); String strNumB = scanner.nextLine(); System.out.print(&quot;请输入运算符:&quot;); String strOper = scanner.nextLine(); try &#123; double result = Operation.getResult(Double.parseDouble(strNumA),Double.parseDouble(strNumB),strOper); System.out.println(&quot;运算结果：&quot;+result); &#125;catch (NumberFormatException e)&#123; System.out.println(&quot;请输入合法值!&quot;); &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如此一来，我们便将调用者与业务逻辑之间进行了解耦和。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，如果我们要增加其他运算呢？如求平方根，求次方的话会怎么做？相信大家的想法是在Operation类中增加case语句不就好了吗？但是这样做的话，我们得更改原程序的代码。通常来说，是很忌讳直接去修改原程序的代码。这时，我们就可以运用面向对象的其他特征了。12345678910111213141516171819202122232425262728293031323334353637383940public abstract class Operation &#123; public abstract double getResult(double numA,double numB) throws Exception;&#125;class OperAdd extends Operation&#123; @Override public double getResult(double numA, double numB) &#123; return numA + numB; &#125;&#125;class OperSub extends Operation&#123; @Override public double getResult(double numA, double numB) &#123; return numA - numB; &#125;&#125;class OperMul extends Operation&#123; @Override public double getResult(double numA, double numB) &#123; return numA * numB; &#125;&#125;class OperDiv extends Operation&#123; @Override public double getResult(double numA, double numB) throws Exception &#123; if(numB == 0) throw new Exception(&quot;除数不能为0!&quot;); return numA / numB; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通过判断运算符的类型，继承父类生成合适的子类对象，利用多态即可。这样的话，当需要其他功能时，我们只需要继续去继承父类即可。而我们生成合适子类的过程中便用到了简单工厂模式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单工厂模式示例代码如下： 12345678910111213141516171819202122public class OperFactory &#123; public Operation createOper(String oper) throws Exception &#123; Operation operation = null; switch (oper)&#123; case &quot;+&quot;: operation = new OperAdd(); break; case &quot;-&quot;: operation = new OperSub(); break; case &quot;*&quot;: operation = new OperMul(); break; case &quot;/&quot;: operation = new OperDiv(); break; default: throw new Exception(&quot;请输入指定运算符&quot;); &#125; return operation; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们进行运算时，让工厂产生合适的子类对象，这样我们就可以进行运算了。123456789101112131415161718192021222324252627public class Program &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入数字A:&quot;); String strNumA = scanner.nextLine(); System.out.print(&quot;请输入数字B:&quot;); String strNumB = scanner.nextLine(); System.out.print(&quot;请输入运算符:&quot;); String strOper = scanner.nextLine(); try &#123; //生成工厂对象 OperFactory factory = new OperFactory(); //生成合适的子类对象 Operation oper = factory.createOper(strOper); //利用多态进行计算 double result = oper.getResult(Double.parseDouble(strNumA),Double.parseDouble(strNumB)); System.out.println(&quot;运算结果:&quot;+result); &#125;catch (NumberFormatException e)&#123; System.out.println(&quot;请输入合法数字！&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个OperFactory像不像一个工厂呢？如饮料厂生产饮料，根据用户的需求去生产合适的饮料。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能还挺过静态工厂模式，那么什么时静态工厂呢？很简单，不过是将生产子类的方法由对象方法提升至类方法，这样我们就可以不用生成工厂对象，直接通过类去调用该方法即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习了简单工厂模式后，我们总结一下什么时候时候该设计模式，首先对需求进行分习，如上可以分离出一个抽象类：运算类。然后该类的方法在不同的条件下有不同的执行过程。那么，此时我们便可以使用简单工厂模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
</search>
